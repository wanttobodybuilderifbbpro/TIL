## 2023. 04. 01. Sat. TIL


boolean 자료형의 경우 true / false에서 왔다갔다 하는데, 여기서 이 둘을 각각 형변환(type conversion)을 통해 살펴보면

Number로 형변환) = true는 1, false는 0으로 형변환(type conversion)되는 모습을 살펴볼 수 있다. 


일반적으로 어떤 값을 boolean으로 변환할 때는 대게 true로 변환된다. 

false로 바뀌는 경우

i). 뭔가 없을 때

ii). 뭔가 비어 있을 때 

iii). 0

iv). NaN

이들을 falsy값이라고 한다. 



일치 비교와 동등 비교에서의 형 변환은

일치 비교는 형 변환이 일어나지 않지만, 

동등 비교에서는 형 변환이 일어난다. 



===== 형변환 틀린 문제 정리

(1) 문자열 '4' 더하기 숫자 '3'입니다. 더하기 연산은 피연산자가 한쪽이라도 문자열이 있을 경우 양쪽 모두를 문자열로 형 변환한 다음 문자열 덧셈을 연산합니다. 결과적으로 1번 선택지는 console.log(typeof ("43")); 가 되어서 콘솔에는 string 이 출력됩니다.

(2) 더하기 기호를 제외한 일반적인 산술연산자들은 연산 되는 값들을 모두 숫자형으로 변환한 다음 연산을 합니다. 3 - true는 불린 true가 숫자 1로 형 변환 되면서 3 - 1이 되는데요. 결과적으로 2번 선택지는 console.log( typeof (2));가 되어서 콘솔에는 number가 출력됩니다.

(3) 숫자 5를 불린형으로 변환한 뒤 true와 곱셈을 한 선택지입니다. 형 변환하는 부분을 조금 정리해보면, 이 코드는 console.log(typeof (true * true));가 되는데요. 곱셈도 뺄셈과 마찬가지로 양쪽 값을 모두 숫자형으로 변환하기 때문에 이 선택지를 결과적으로 다시 정리하면 console.log(typeof (1 * 1));이 되어서 콘솔에는 number가 출력됩니다.

(4) 부등호로 두 값의 크고 작음을 비교할 때도 특별한 경우를 제외하면 보통 숫자형으로 바꿔서 비교합니다.
이 선택지를 다시 정리하면 console.log(typeof (1 < 0));가 되는데요, 1은 0보다 작다는 거짓이기 때문에 결과적으로는 console.log(typeof (false));가 되어서 boolean 이 출력됩니다.


일치, 불일치 비교는 두 값이 자료형까지 같은지 엄격하게 비교를 하고, 동등, 부등 비교는 형 변환을 허용해서 상대적으로 느슨하게 서로를 비교.

당장은 자료형이 다르지만, 만약 형 변환을 했을 때 값이 같다면 true를 반환하는 것. 따라서 상황에 따라 일치와 동등, 불일치와 부등은 서로 전혀 다른 결과를 반환할 수 있다.


```// 일치 동등 비교
console.log(2 === '2'); // false 
console.log(2 == '2'); // true

// 불일치 부등 비교
console.log(2 !== '2'); // true
console.log(2 != '2'); // false
```



==== 틀린 문제 정리 2

```
1 console.log(0 !== Number(false));

2 console.log(Number(true) == String(1));

3 console.log('5' / true != '5');

4 console.log(5 % 2 === Boolean(2) * true);
```


(1) 숫자 0과, 불린 false를 숫자형으로 형 변환한 값의 불일치 비교입니다. 불린 false를 숫자형으로 형 변환하면 숫자 0이죠? 두 값은 서로 일치하기 때문에, 불일치 비교에서는 false가 반환됩니다.

(2) 불린 true를 숫자형으로 형 변환한 값과 숫자 1을 문자열로 형 변환한 값의 동등 비교입니다. 이 연산식을 간단하게 정리하면 1 == '1'이 되는데요. 문자열 '1'과 숫자 1은 형 변환 시 값이 서로 같을 수 있기 때문에 두 값의 동등 비교는 true 가 반환됩니다.

(3) 문자열 '5' 나누기 불린 true의 결괏값과 문자열 '5'의 부등 비교입니다. 문자열 '5' 나누기 불린 true는 나누기 연산에 의해서 두 값 모두 숫자형으로 형 변환되는데요. 그러면 이 부분은 모두 숫자형 값으로 5 / 1이 되고 결과적으로 3번 선택지의 연산식은 5 != '5'가 됩니다. 숫자 5와 문자열 '5'는 동등하기 때문에, 부등 비교에서는 false가 반환됩니다.

(4) 숫자 5와 숫자 2의 나머지 연산의 결괏값과 숫자 2를 불린 형태로 형 변환한 값에 불린 true를 곱한 결괏값의 일치비교입니다. 일치비교의 왼편부터 살펴보면, 숫자 5와 숫자 2의 나머지연산의 결과는 숫자 1입니다. 다음으로 오른편을 보면 일단 숫자 2를 불린 형태로 형 변환한 값은 true인데요. 이 연산식을 다시 정리하면 true * true가 됩니다. 그런데 곱셈연산자에 의해서 true가 모두 숫자형으로 또 형 변환이 되서 1 * 1의 결과인 숫자 1이 오른쪽 부분의 결괏값이 됩니다.
숫자 1과, 숫자 1의 일치비교니깐 true가 반환되겠죠?

따라서 연산의 결과가 true인 선택지는 2번, 4번입니다.



=============
의도적으로 '값이 없다'를 나타내려면

```undefinded``` 보단  ```null``` 사용을 권한다.

cf. null = 의도적인 없음 // undefined = 처음부터 없음(변수 선언만 했고 값을 넣지 않았음)


=========== 오답노트

```
let x;
console.log(x);
let y = x;
x = null;
console.log(y);
console.log(x);
x = y;
console.log(x);
```

순서대로 올바르게 출력하면?

답 : ``` undefined -> undefined -> null -> undefined ```



======오답풀이

이번에도 첫 번째 줄은 아무런 값을 할당하지 않고 변수 x를 선언했습니다.
두 번째 줄에서 변수 y는 null값을 할당했는데요. 결국 x는 undefined, y는 null입니다.
문제의 예시를 다시 정리해보면, 다음과 같습니다.


